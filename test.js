const arr = ['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
console.log(arr);

arr.push('해그리드');
console.log(arr);
/* 
push : 맨 끝에 요소 추가 - (요소-여러개 가능)
['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스', '해그리드'];
 */

arr.pop();
console.log(arr);
/* 
pop : 맨 끝 요소 삭제
['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
*/

arr.shift();
console.log(arr);
/* 
shift : 맨 앞 요소 삭제
['론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
*/

arr.unshift('해리');
console.log(arr);
/* 
unshift : 맨 앞 요소 추가 - (요소-여러개 가능)
['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
*/

arr.splice(1,1);
console.log(arr);
/* 
splice(조작할 위치-숫자 , 제거할 갯수-숫자) : 요소 삭제
[ '해리', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스' ]
*/

arr.splice(0,2,'해리', '레귤러스');
console.log(arr);

/* 
splice(조작할 위치-숫자 , 제거할 갯수-숫자 , 요소) : 요소  변경
[ '해리', '레귤러스', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스' ]
*/

arr.splice(4,0,'릴리', '페튜니아');
console.log(arr);

/* 
splice(조작할 위치-숫자 , 제거할 갯수-숫자 , 요소) : 요소  추가 -> 제거할 갯수를 0으로 할 경우 
[ '해리', '레귤러스', '헤르미온느', '말포이', '릴리', '페튜니아', '덤블도어', '스네이프', '시리우스', '리무스' ]
*/

let arr2 = arr.slice(4,6); 
console.log(arr);
console.log(arr2);
/* 
slice(추출 시작 위치-숫자, 추출 종료 위치(포함하지 않음  위치 전까지 추출)-숫자) : 배열에서 요소를 추출 하여 새로운 배열을 만듦 -> 원래 배열은 변화 없음  
console.log(arr);
-> [ '해리', '레귤러스', '헤르미온느', '말포이', '릴리', '페튜니아', '덤블도어', '스네이프', '시리우스', '리무스' ]

즉, slice는 요소를 추출하기만 할 뿐 원래의 배열에 영향을 미치지 않음 
console.log(arr2);
-> [ '릴리', '페튜니아' ]
*/

let arr3 = arr.concat('지니', '네빌');
console.log(arr);
console.log(arr3);
/* 
contact(요소1, 요소2....) : 원래 배열에 요소를 추가하여 새로운 배열을 만듦
slice와 마찬가지로 원래의 배열에는 영향을 끼치지 않음

배열 형태의 요소도 이어 붙일 수 있음
arr.concat(['지니', '네빌'], '도비');


console.log(arr);
-> [ '해리', '레귤러스', '헤르미온느', '말포이', '릴리', '페튜니아', '덤블도어', '스네이프', '시리우스', '리무스' ]

console.log(arr3);
-> [ '해리', '레귤러스', '헤르미온느', '말포이', '릴리', '페튜니아', '덤블도어', '스네이프', '시리우스', '리무스','지니', '네빌']
*/

// arr.forEach()


console.log(arr.indexOf('말포이',0));
/* 
indexOf(요소, 기준 위치-숫자) : 배열에서 지정한 요소가 기준 위치에서 몇번째 요소인지 확인 할 수 있음
요소가 배열에 없다면 -1 이 나옴
console.log(arr.indexOf('말포이',0)); arr의 0번째에서 시작하여 '말포이'가 위치한 인덱스
-> 2
*/

console.log(Array.isArray(arr));
/* 
Array.isArray() : ()안에는 객체가 오든 배열이 오든 상관 없으나 배열을 판단해주는 메서드이기 때문에
배열이 아닌 요소가 오게 되면 false가 나옴 (불리언 타입으로 반환)
arr는 배열이기 때문에 true 가 나옴
*/


arr1 = ['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
console.log(arr1.at(-4));
console.log(arr1.at(5));
/* 
at() : 요소 의 값을 얻을 수 있는 메서드 
-> 기본 매서드 arr[0~arr.length-1]까지 만 사용 가능하나
-> arr.at(음수 인덱스도 가능) * 단, 배열의 길이의 마이너스까지만 가능
['해리', '론', '헤르미온느', '말포이', '덤블도어', '스네이프', '시리우스', '리무스'];
[0/-8 ,  1/-7,    2/-6,      3/-5,     4/-4,       5/-3,      6/-2,     7/-1];

*/



/* 
1. forEach()
2. push() y
3. pop() y
4. shift() y
5. unshift() y 
6. indexOf() y
7. splice() y
8. slice() y
9. from()
10. isArray() y
11. at()
12. concat() y
13. every()
14. filter()
15. findIndex()
16. includes()
17. join()
18. map()
19. reduce()
20. some()
21. sort()
22. toString()
23. values()
*/






